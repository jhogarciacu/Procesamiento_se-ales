# -*- coding: utf-8 -*-
"""SENAL_ESCALON.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IzIZ9e5YzYaiA3WR-fsYi7kRPm5PF3y6
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import windows
from scipy.fft import fft, fftfreq, ifft

# Parámetros
fs = 2000           # Frecuencia de muestreo en Hz
step_duration = 0.05  # Duración de cada escalón en segundos
frequencies = np.arange(10, 510, 10)  # De 10 a 500 Hz, pasos de 10
samples_per_step = int(fs * step_duration)

# Generar la señal escalón
signal = np.array([])
for f in frequencies:
    t_step = np.linspace(0, step_duration, samples_per_step, endpoint=False)
    tone = np.sin(2 * np.pi * f * t_step)
    signal = np.concatenate((signal, tone))

t = np.linspace(0, len(signal)/fs, len(signal), endpoint=False)

# Aplicar ventana de Hamming
window = windows.hamming(len(signal))
windowed_signal = signal * window

N = len(windowed_signal)
xf = fftfreq(N, 1/fs)
yf = fft(windowed_signal)

# Magnitud de la FFT (solo parte positiva)
xf_pos = xf[:N//2]
yf_pos = 2.0 / N * np.abs(yf[:N//2])

# Copiamos la FFT para modificarla
yf_eq = yf.copy()

# Definimos la banda a modificar
low_cut = 90
high_cut = 110
gain = 2.0  # Amplificar al doble

# Índices de frecuencia a modificar
indices = np.where((xf >= low_cut) & (xf <= high_cut))[0]
indices = np.concatenate((indices, np.where((xf <= -low_cut) & (xf >= -high_cut))[0]))  # Negativas también

# Aplicar ganancia
yf_eq[indices] *= gain

# Inversa de FFT para obtener señal modificada
signal_eq = np.real(ifft(yf_eq))

plt.figure(figsize=(14, 6))

plt.subplot(2, 2, 1)
plt.plot(t, signal)
plt.title("Señal Original")

plt.subplot(2, 2, 2)
plt.plot(xf_pos, yf_pos)
plt.title("FFT Original")

plt.subplot(2, 2, 3)
plt.plot(t, signal_eq)
plt.title("Señal con Ecualización")

plt.subplot(2, 2, 4)
yf_eq_pos = 2.0/ N * np.abs(yf_eq[:N//2])
plt.plot(xf_pos, yf_eq_pos)
plt.title("FFT Ecualizada")

plt.tight_layout()
plt.show()

